From: Robert Hedges <rhedges@truefitness.com>
Date: Thu, 29 May 2014 16:32:28 -0500
Subject: Reformatted patches.

---
 debian/patches/0001-lower_sink_ranking.patch       |   22 +
 debian/patches/0002-disable_hal.patch              |  182 ++++
 .../patches/0003-Fix-return-code-of-hid2hci.patch  |   66 ++
 debian/patches/0004-alsalib.patch                  |   38 +
 ...Gateway-and-Source-audio-profiles-by-defa.patch |   40 +
 debian/patches/0006-fix_ftbfs_with_c99.patch       |   35 +
 ...s-parsing-inline-assembly-for-calculating.patch |   26 +
 debian/patches/0008-dinovo_edge_keyboard.patch     |   25 +
 ...ork-fix-network-Connect-method-parameters.patch |   24 +
 ...-Permit-concurrent-use-of-AG-and-HF-roles.patch |   47 +
 ...ix-GDBus-flags-after-conversion-to-macros.patch |   81 ++
 .../0012-network-NULL-dereference-fix.patch        |   31 +
 ...ot-adding-watches-when-io-channel-is-conn.patch |   98 +++
 .../0014-True-volume-control-3859147d82.diff.patch |  123 +++
 .../0015-True-Updated-control-api.txt-file.patch   |   44 +
 debian/patches/0016-True-Bluetooth-metadata.patch  |  917 ++++++++++++++++++++
 .../0017-True-Remove-remote-version-call.patch     |   49 ++
 17 files changed, 1848 insertions(+)
 create mode 100644 debian/patches/0001-lower_sink_ranking.patch
 create mode 100644 debian/patches/0002-disable_hal.patch
 create mode 100644 debian/patches/0003-Fix-return-code-of-hid2hci.patch
 create mode 100644 debian/patches/0004-alsalib.patch
 create mode 100644 debian/patches/0005-Enable-the-Gateway-and-Source-audio-profiles-by-defa.patch
 create mode 100644 debian/patches/0006-fix_ftbfs_with_c99.patch
 create mode 100644 debian/patches/0007-Fix-FTBFS-is-parsing-inline-assembly-for-calculating.patch
 create mode 100644 debian/patches/0008-dinovo_edge_keyboard.patch
 create mode 100644 debian/patches/0009-network-fix-network-Connect-method-parameters.patch
 create mode 100644 debian/patches/0010-audio-Permit-concurrent-use-of-AG-and-HF-roles.patch
 create mode 100644 debian/patches/0011-Fix-GDBus-flags-after-conversion-to-macros.patch
 create mode 100644 debian/patches/0012-network-NULL-dereference-fix.patch
 create mode 100644 debian/patches/0013-input-Fix-not-adding-watches-when-io-channel-is-conn.patch
 create mode 100644 debian/patches/0014-True-volume-control-3859147d82.diff.patch
 create mode 100644 debian/patches/0015-True-Updated-control-api.txt-file.patch
 create mode 100644 debian/patches/0016-True-Bluetooth-metadata.patch
 create mode 100644 debian/patches/0017-True-Remove-remote-version-call.patch

diff --git a/debian/patches/0001-lower_sink_ranking.patch b/debian/patches/0001-lower_sink_ranking.patch
new file mode 100644
index 0000000..c48f3d2
--- /dev/null
+++ b/debian/patches/0001-lower_sink_ranking.patch
@@ -0,0 +1,22 @@
+From: Sebastian Dr√∂ge <slomo@circular-chaos.org>
+Date: 2012-06-14 03:04:20.000000000 +1200
+Subject:a2dpsink should have a rank < GST_RANK_MARGINAL
+
+Updated by Nobuhiro Iwamatsu <iwamatsu@debian.org>
+Debian BTS: http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=571595
+---
+ audio/gsta2dpsink.c |    2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/audio/gsta2dpsink.c b/audio/gsta2dpsink.c
+index c8f6346..7f6d0c0 100644
+--- a/audio/gsta2dpsink.c
++++ b/audio/gsta2dpsink.c
+@@ -725,5 +725,5 @@ static void gst_a2dp_sink_init(GstA2dpSink *self,
+ gboolean gst_a2dp_sink_plugin_init(GstPlugin *plugin)
+ {
+ 	return gst_element_register(plugin, "a2dpsink",
+-			GST_RANK_MARGINAL, GST_TYPE_A2DP_SINK);
++			GST_RANK_MARGINAL-1, GST_TYPE_A2DP_SINK);
+ }
+-- 
diff --git a/debian/patches/0002-disable_hal.patch b/debian/patches/0002-disable_hal.patch
new file mode 100644
index 0000000..c652b74
--- /dev/null
+++ b/debian/patches/0002-disable_hal.patch
@@ -0,0 +1,182 @@
+From: Martin Pitt <martin.pitt@ubuntu.com>
+Date: 2012-06-14 03:04:20.000000000 +1200
+Subject: Disable usage of Hal in the telephony plugins, and disable the hal plugin. They do not do very useful things anyway, and just cause hal to start up, which is expensive.
+
+Updated by Michael Biebl <biebl@debian.org>
+Updated by Nobuhiro Iwamatsu <iwamatsu@debian.org>
+Debian BTS: http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=599023
+---
+ audio/telephony-maemo5.c |    9 ++++++++-
+ audio/telephony-maemo6.c |   10 +++++++++-
+ audio/telephony-ofono.c  |    5 ++++-
+ 3 files changed, 21 insertions(+), 3 deletions(-)
+
+diff --git a/audio/telephony-maemo5.c b/audio/telephony-maemo5.c
+index 8a00296..3db8bb7 100644
+--- a/audio/telephony-maemo5.c
++++ b/audio/telephony-maemo5.c
+@@ -1385,6 +1385,7 @@ static gboolean iter_get_basic_args(DBusMessageIter *iter,
+ 	return type == DBUS_TYPE_INVALID ? TRUE : FALSE;
+ }
+ 
++#if 0 /* Disable hal */
+ static void hal_battery_level_reply(DBusPendingCall *call, void *user_data)
+ {
+ 	DBusError err;
+@@ -1501,6 +1502,7 @@ static void handle_hal_property_modified(DBusMessage *msg)
+ 		dbus_message_iter_next(&array);
+ 	}
+ }
++#endif /* Disable hal */
+ 
+ static void csd_call_free(struct csd_call *call)
+ {
+@@ -1715,6 +1717,7 @@ done:
+ 	dbus_message_unref(reply);
+ }
+ 
++#if 0 /* Disable hal */
+ static void hal_find_device_reply(DBusPendingCall *call, void *user_data)
+ {
+ 	DBusError err;
+@@ -1768,6 +1771,7 @@ static void hal_find_device_reply(DBusPendingCall *call, void *user_data)
+ done:
+ 	dbus_message_unref(reply);
+ }
++#endif /* Disable hal */
+ 
+ static void phonebook_read_reply(DBusPendingCall *call, void *user_data)
+ {
+@@ -2019,9 +2023,11 @@ static DBusHandlerResult signal_filter(DBusConnection *conn,
+ 	else if (dbus_message_is_signal(msg, NETWORK_INTERFACE,
+ 					"signal_strength_change"))
+ 		handle_signal_strength_change(msg);
++#if 0 /* Disable hal */
+ 	else if (dbus_message_is_signal(msg, "org.freedesktop.Hal.Device",
+ 					"PropertyModified"))
+ 		handle_hal_property_modified(msg);
++#endif /* Disable hal */
+ 	else if (dbus_message_is_signal(msg, SSC_DBUS_IFACE,
+ 						"modem_state_changed_ind"))
+ 		handle_modem_state(msg);
+@@ -2078,6 +2084,7 @@ int telephony_init(void)
+ 
+ 	telephony_ready_ind(features, maemo_indicators, BTRH_NOT_SUPPORTED,
+ 								chld_str);
++#if 0 /* Disable hal */
+ 	if (send_method_call("org.freedesktop.Hal",
+ 				"/org/freedesktop/Hal/Manager",
+ 				"org.freedesktop.Hal.Manager",
+@@ -2086,7 +2093,7 @@ int telephony_init(void)
+ 				DBUS_TYPE_STRING, &battery_cap,
+ 				DBUS_TYPE_INVALID) < 0)
+ 		error("Unable to send HAL method call");
+-
++#endif /* Disable hal */
+ 	return 0;
+ }
+ 
+diff --git a/audio/telephony-maemo6.c b/audio/telephony-maemo6.c
+index 0727ffe..d71d8c1 100644
+--- a/audio/telephony-maemo6.c
++++ b/audio/telephony-maemo6.c
+@@ -1575,6 +1575,7 @@ static gboolean iter_get_basic_args(DBusMessageIter *iter,
+ 	return type == DBUS_TYPE_INVALID ? TRUE : FALSE;
+ }
+ 
++#if 0 /* Disable hal */
+ static void hal_battery_level_reply(DBusPendingCall *call, void *user_data)
+ {
+ 	DBusError err;
+@@ -1690,6 +1691,7 @@ static void handle_hal_property_modified(DBusMessage *msg)
+ 		dbus_message_iter_next(&array);
+ 	}
+ }
++#endif /* Disable hal */
+ 
+ static void csd_call_free(void *data)
+ {
+@@ -2044,9 +2046,11 @@ static gboolean signal_filter(DBusConnection *conn, DBusMessage *msg,
+ 	else if (dbus_message_is_signal(msg, CSD_CSNET_SIGNAL,
+ 				"SignalBarsChanged"))
+ 		handle_signal_bars_changed(msg);
++#if 0 /* Disable hal */
+ 	else if (dbus_message_is_signal(msg, "org.freedesktop.Hal.Device",
+ 					"PropertyModified"))
+ 		handle_hal_property_modified(msg);
++#endif
+ 	else if (dbus_message_is_signal(msg, SSC_DBUS_IFACE,
+ 						"modem_state_changed_ind"))
+ 		handle_modem_state(msg);
+@@ -2065,6 +2069,7 @@ static void add_watch(const char *sender, const char *path,
+ 	watches = g_slist_prepend(watches, GUINT_TO_POINTER(watch));
+ }
+ 
++#if 0 /* Disable hal */
+ static void hal_find_device_reply(DBusPendingCall *call, void *user_data)
+ {
+ 	DBusError err;
+@@ -2115,6 +2120,8 @@ done:
+ 	remove_pending(call);
+ }
+ 
++#endif /* Disable hal */
++
+ int telephony_init(void)
+ {
+ 	const char *battery_cap = "battery";
+@@ -2154,6 +2161,7 @@ int telephony_init(void)
+ 
+ 	telephony_ready_ind(features, maemo_indicators, BTRH_NOT_SUPPORTED,
+ 								chld_str);
++#if 0 /* Disable hal */
+ 	if (send_method_call("org.freedesktop.Hal",
+ 				"/org/freedesktop/Hal/Manager",
+ 				"org.freedesktop.Hal.Manager",
+@@ -2162,7 +2170,7 @@ int telephony_init(void)
+ 				DBUS_TYPE_STRING, &battery_cap,
+ 				DBUS_TYPE_INVALID) < 0)
+ 		error("Unable to send HAL method call");
+-
++#endif 
+ 	return 0;
+ }
+ 
+diff --git a/audio/telephony-ofono.c b/audio/telephony-ofono.c
+index 961fedd..5ed7400 100644
+--- a/audio/telephony-ofono.c
++++ b/audio/telephony-ofono.c
+@@ -1343,6 +1343,7 @@ static gboolean handle_manager_modem_removed(DBusConnection *conn,
+ 	return TRUE;
+ }
+ 
++#if 0 /* Disable hal */
+ static void hal_battery_level_reply(DBusPendingCall *call, void *user_data)
+ {
+ 	DBusMessage *reply;
+@@ -1526,6 +1527,7 @@ done:
+ 	dbus_message_unref(reply);
+ 	remove_pending(call);
+ }
++#endif /* Disable hal */
+ 
+ static void handle_service_connect(DBusConnection *conn, void *user_data)
+ {
+@@ -1581,6 +1583,7 @@ int telephony_init(void)
+ 
+ 	watches = g_slist_prepend(watches, GUINT_TO_POINTER(watch));
+ 
++#if 0 /* Disable hal */
+ 	ret = send_method_call("org.freedesktop.Hal",
+ 				"/org/freedesktop/Hal/Manager",
+ 				"org.freedesktop.Hal.Manager",
+@@ -1590,7 +1593,7 @@ int telephony_init(void)
+ 				DBUS_TYPE_INVALID);
+ 	if (ret < 0)
+ 		return ret;
+-
++#endif
+ 	DBG("telephony_init() successfully");
+ 
+ 	telephony_ready_ind(features, ofono_indicators, BTRH_NOT_SUPPORTED,
+-- 
diff --git a/debian/patches/0003-Fix-return-code-of-hid2hci.patch b/debian/patches/0003-Fix-return-code-of-hid2hci.patch
new file mode 100644
index 0000000..116c0b7
--- /dev/null
+++ b/debian/patches/0003-Fix-return-code-of-hid2hci.patch
@@ -0,0 +1,66 @@
+From: Nobuhiro Iwamatsu <iwamatsu@debian.org>
+Date: Thu, 29 May 2014 13:35:56 -0500
+Subject:bluez: getting a "Logitech, Inc. diNovo Edge Keyboard" working
+Origin: Nobuhiro Iwamatsu <iwamatsu@debian.org>
+
+Debian BTS: http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=626975
+---
+ tools/hid2hci.c |   10 ++++++++--
+ 1 file changed, 8 insertions(+), 2 deletions(-)
+
+diff --git a/tools/hid2hci.c b/tools/hid2hci.c
+index e3a5b2e..f73f035 100644
+--- a/tools/hid2hci.c
++++ b/tools/hid2hci.c
+@@ -240,7 +240,7 @@ int main(int argc, char *argv[])
+ 	enum mode mode = HCI;
+ 	const char *devpath = NULL;
+ 	int err = -1;
+-	int rc = 1;
++	int rc = 0;
+ 
+ 	for (;;) {
+ 		int option;
+@@ -288,13 +288,16 @@ int main(int argc, char *argv[])
+ 	}
+ 
+ 	udev = udev_new();
+-	if (udev == NULL)
++	if (udev == NULL) {
++		rc = errno;
+ 		goto exit;
++	}
+ 
+ 	snprintf(syspath, sizeof(syspath), "/sys/%s", devpath);
+ 	udev_dev = udev_device_new_from_syspath(udev, syspath);
+ 	if (udev_dev == NULL) {
+ 		fprintf(stderr, "error: could not find '%s'\n", devpath);
++		rc = errno;
+ 		goto exit;
+ 	}
+ 
+@@ -312,6 +315,7 @@ int main(int argc, char *argv[])
+ 			dev = udev_device_get_parent_with_subsystem_devtype(dev, "usb", "usb_device");
+ 			if (dev == NULL) {
+ 				fprintf(stderr, "error: could not find usb_device for '%s'\n", devpath);
++				rc = errno;
+ 				goto exit;
+ 			}
+ 		}
+@@ -320,6 +324,7 @@ int main(int argc, char *argv[])
+ 		if (handle == NULL) {
+ 			fprintf(stderr, "error: unable to handle '%s'\n",
+ 				udev_device_get_syspath(dev));
++			rc = errno;
+ 			goto exit;
+ 		}
+ 		err = usb_switch(handle, mode);
+@@ -331,6 +336,7 @@ int main(int argc, char *argv[])
+ 		device = udev_device_get_devnode(udev_dev);
+ 		if (device == NULL) {
+ 			fprintf(stderr, "error: could not find hiddev device node\n");
++			rc = errno;
+ 			goto exit;
+ 		}
+ 		err = hid_switch_logitech(device);
+-- 
diff --git a/debian/patches/0004-alsalib.patch b/debian/patches/0004-alsalib.patch
new file mode 100644
index 0000000..8e30fee
--- /dev/null
+++ b/debian/patches/0004-alsalib.patch
@@ -0,0 +1,38 @@
+From: Steve Langasek <steve.langasek@canonical.com>
+Date: 2012-06-23 04:36:49.000000000 +1200
+Subject: Please install ALSA plugin in the multiarch directory
+
+Updated by Nobuhiro Iwamatsu <iwamatsu@debian.org>
+Debian BTS: http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=634976
+---
+ Makefile.am  |    2 +-
+ acinclude.m4 |    2 ++
+ 2 files changed, 3 insertions(+), 1 deletion(-)
+
+diff --git a/Makefile.am b/Makefile.am
+index 1c214c6..7e1793b 100644
+--- a/Makefile.am
++++ b/Makefile.am
+@@ -337,7 +337,7 @@ EXTRA_DIST += src/genbuiltin src/bluetooth.conf src/org.bluez.service \
+ 			proximity/proximity.conf
+ 
+ if ALSA
+-alsadir = $(libdir)/alsa-lib
++alsadir = $(ALSA_LIBDIR)/alsa-lib
+ 
+ alsa_LTLIBRARIES = audio/libasound_module_pcm_bluetooth.la \
+ 				audio/libasound_module_ctl_bluetooth.la
+diff --git a/acinclude.m4 b/acinclude.m4
+index 1d6d736..6b00d78 100644
+--- a/acinclude.m4
++++ b/acinclude.m4
+@@ -119,6 +119,8 @@ AC_DEFUN([AC_PATH_ALSA], [
+ 	AC_CHECK_LIB(rt, clock_gettime, ALSA_LIBS="$ALSA_LIBS -lrt", alsa_found=no)
+ 	AC_SUBST(ALSA_CFLAGS)
+ 	AC_SUBST(ALSA_LIBS)
++	ALSA_LIBDIR=`$PKG_CONFIG --variable=libdir alsa 2>/dev/null`
++	AC_SUBST(ALSA_LIBDIR)
+ ])
+ 
+ AC_DEFUN([AC_PATH_USB], [
+-- 
diff --git a/debian/patches/0005-Enable-the-Gateway-and-Source-audio-profiles-by-defa.patch b/debian/patches/0005-Enable-the-Gateway-and-Source-audio-profiles-by-defa.patch
new file mode 100644
index 0000000..0939473
--- /dev/null
+++ b/debian/patches/0005-Enable-the-Gateway-and-Source-audio-profiles-by-defa.patch
@@ -0,0 +1,40 @@
+From: Mathieu Trudel-Lapierre <mathieu.trudel-lapierre@canonical.com>
+Subject: Enable the Gateway and Source audio profiles by default.
+Bug-Ubuntu: https://bugs.launchpad.net/ubuntu/+source/bluez/+bug/948613
+
+Those can be disabled by the user in /etc/bluetooth/audio.conf if necessary.
+---
+ audio/a2dp.c    |    2 +-
+ audio/manager.c |    4 ++--
+ 2 files changed, 3 insertions(+), 3 deletions(-)
+
+diff --git a/audio/a2dp.c b/audio/a2dp.c
+index 404be53..b663030 100644
+--- a/audio/a2dp.c
++++ b/audio/a2dp.c
+@@ -1444,7 +1444,7 @@ int a2dp_register(DBusConnection *conn, const bdaddr_t *src, GKeyFile *config)
+ {
+ 	int sbc_srcs = 0, sbc_sinks = 0;
+ 	int mpeg12_srcs = 0, mpeg12_sinks = 0;
+-	gboolean source = TRUE, sink = FALSE, socket = FALSE;
++	gboolean source = TRUE, sink = TRUE, socket = FALSE;
+ 	gboolean delay_reporting = FALSE;
+ 	char *str;
+ 	GError *err = NULL;
+diff --git a/audio/manager.c b/audio/manager.c
+index d442d1d..99e03bb 100644
+--- a/audio/manager.c
++++ b/audio/manager.c
+@@ -110,9 +110,9 @@ static GSList *devices = NULL;
+ static struct enabled_interfaces enabled = {
+ 	.hfp		= TRUE,
+ 	.headset	= TRUE,
+-	.gateway	= FALSE,
++	.gateway	= TRUE,
+ 	.sink		= TRUE,
+-	.source		= FALSE,
++	.source		= TRUE,
+ 	.control	= TRUE,
+ 	.socket		= FALSE,
+ 	.media		= TRUE,
+-- 
diff --git a/debian/patches/0006-fix_ftbfs_with_c99.patch b/debian/patches/0006-fix_ftbfs_with_c99.patch
new file mode 100644
index 0000000..51ac98f
--- /dev/null
+++ b/debian/patches/0006-fix_ftbfs_with_c99.patch
@@ -0,0 +1,35 @@
+From: Bluez devel
+Date: 2012-05-01 15:49:22.741014152 +0100
+Subject: 09_fix_ftbfs_with_c99.patch
+Origin: http://permalink.gmane.org/gmane.linux.bluez.kernel/22306
+
+---
+ lib/bluetooth.h |    8 ++++----
+ 1 file changed, 4 insertions(+), 4 deletions(-)
+
+diff --git a/lib/bluetooth.h b/lib/bluetooth.h
+index 0fc4508..43a9237 100644
+--- a/lib/bluetooth.h
++++ b/lib/bluetooth.h
+@@ -140,16 +140,16 @@ enum {
+ #define bt_get_unaligned(ptr)			\
+ ({						\
+ 	struct __attribute__((packed)) {	\
+-		typeof(*(ptr)) __v;		\
+-	} *__p = (typeof(__p)) (ptr);		\
++		__typeof__(*(ptr)) __v;		\
++	} *__p = (__typeof__(__p)) (ptr);	\
+ 	__p->__v;				\
+ })
+ 
+ #define bt_put_unaligned(val, ptr)		\
+ do {						\
+ 	struct __attribute__((packed)) {	\
+-		typeof(*(ptr)) __v;		\
+-	} *__p = (typeof(__p)) (ptr);		\
++		__typeof__(*(ptr)) __v;		\
++	} *__p = (__typeof__(__p)) (ptr);	\
+ 	__p->__v = (val);			\
+ } while(0)
+ 
+-- 
diff --git a/debian/patches/0007-Fix-FTBFS-is-parsing-inline-assembly-for-calculating.patch b/debian/patches/0007-Fix-FTBFS-is-parsing-inline-assembly-for-calculating.patch
new file mode 100644
index 0000000..87480af
--- /dev/null
+++ b/debian/patches/0007-Fix-FTBFS-is-parsing-inline-assembly-for-calculating.patch
@@ -0,0 +1,26 @@
+From: Mathieu Trudel-Lapierre <mathieu.trudel-lapierre@canonical.com>
+Date: Thu, 29 May 2014 13:35:56 -0500
+Subject: Fix FTBFS is parsing inline assembly for calculating MMX
+ scalefactors
+
+Without this patch, bluez fails to compile when building using GCC 4.7; for
+test-rebuild-20111222.
+See also https://launchpadlibrarian.net/88149127/buildlog_ubuntu-precise-i386.bluez_4.96-3ubuntu4_FAILEDTOBUILD.txt.gz
+---
+ sbc/sbc_primitives_mmx.c |    2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/sbc/sbc_primitives_mmx.c b/sbc/sbc_primitives_mmx.c
+index 27e9a56..a4d2f20 100644
+--- a/sbc/sbc_primitives_mmx.c
++++ b/sbc/sbc_primitives_mmx.c
+@@ -318,7 +318,7 @@ static void sbc_calc_scalefactors_mmx(
+ 				"movl          %k0, 4(%3)\n"
+ 			: "+r" (blk)
+ 			: "r" (&sb_sample_f[0][ch][sb]),
+-				"i" ((char *) &sb_sample_f[1][0][0] -
++				"r" ((char *) &sb_sample_f[1][0][0] -
+ 					(char *) &sb_sample_f[0][0][0]),
+ 				"r" (&scale_factor[ch][sb]),
+ 				"r" (&consts),
+-- 
diff --git a/debian/patches/0008-dinovo_edge_keyboard.patch b/debian/patches/0008-dinovo_edge_keyboard.patch
new file mode 100644
index 0000000..ffa80da
--- /dev/null
+++ b/debian/patches/0008-dinovo_edge_keyboard.patch
@@ -0,0 +1,25 @@
+From: Tommy <mesilliac@gmail.com>
+Date: 2012-07-27 14:28:05.426609000 +1200
+Subject: work around Logitech diNovo Edge keyboard firmware issue
+
+---
+ scripts/bluetooth-hid2hci.rules |    5 ++++-
+ 1 file changed, 4 insertions(+), 1 deletion(-)
+
+diff --git a/scripts/bluetooth-hid2hci.rules b/scripts/bluetooth-hid2hci.rules
+index 0687c8a..2a571e5 100644
+--- a/scripts/bluetooth-hid2hci.rules
++++ b/scripts/bluetooth-hid2hci.rules
+@@ -11,7 +11,10 @@ ATTR{bInterfaceClass}=="03", ATTR{bInterfaceSubClass}=="01", ATTR{bInterfaceProt
+   RUN+="hid2hci --method=dell --devpath=%p", ENV{HID2HCI_SWITCH}="1"
+ 
+ # Logitech devices
+-KERNEL=="hiddev*", ATTRS{idVendor}=="046d", ATTRS{idProduct}=="c70[345abce]|c71[34bc]", \
++KERNEL=="hiddev*", ATTRS{idVendor}=="046d", ATTRS{idProduct}=="c70[345abce]|c71[3bc]", \
++  RUN+="hid2hci --method=logitech-hid --devpath=%p"
++# Logitech, Inc. diNovo Edge Keyboard
++KERNEL=="hidraw*", ATTRS{idVendor}=="046d", ATTRS{idProduct}=="c714", \
+   RUN+="hid2hci --method=logitech-hid --devpath=%p"
+ 
+ ENV{DEVTYPE}!="usb_device", GOTO="hid2hci_end"
+-- 
diff --git a/debian/patches/0009-network-fix-network-Connect-method-parameters.patch b/debian/patches/0009-network-fix-network-Connect-method-parameters.patch
new file mode 100644
index 0000000..9c570f8
--- /dev/null
+++ b/debian/patches/0009-network-fix-network-Connect-method-parameters.patch
@@ -0,0 +1,24 @@
+From: Gustavo Padovan <gustavo.padovan@collabora.co.uk>
+Date: Sat, 30 Jun 2012 00:39:05 -0300
+Subject: network: fix network Connect() method parameters
+
+---
+ network/connection.c |    4 +++-
+ 1 file changed, 3 insertions(+), 1 deletion(-)
+
+diff --git a/network/connection.c b/network/connection.c
+index 544ec3a..59423a9 100644
+--- a/network/connection.c
++++ b/network/connection.c
+@@ -554,7 +554,9 @@ static void path_unregister(void *data)
+ 
+ static const GDBusMethodTable connection_methods[] = {
+ 	{ GDBUS_ASYNC_METHOD("Connect",
+-			NULL, NULL, connection_connect) },
++				GDBUS_ARGS({"uuid", "s"}),
++				GDBUS_ARGS({"interface", "s"}),
++				connection_connect) },
+ 	{ GDBUS_METHOD("Disconnect",
+ 			NULL, NULL, connection_disconnect) },
+ 	{ GDBUS_METHOD("GetProperties",
+-- 
diff --git a/debian/patches/0010-audio-Permit-concurrent-use-of-AG-and-HF-roles.patch b/debian/patches/0010-audio-Permit-concurrent-use-of-AG-and-HF-roles.patch
new file mode 100644
index 0000000..640f120
--- /dev/null
+++ b/debian/patches/0010-audio-Permit-concurrent-use-of-AG-and-HF-roles.patch
@@ -0,0 +1,47 @@
+From:  <frederic.dalleau@linux.intel.com>
+Date: Fri, 22 Jun 2012 16:11:25 +0200
+Subject: audio: Permit concurrent use of AG and HF roles
+
+If a device supports both HF and AG roles, then if a SCO connection
+related to AG profile happens, the connection is rejected because HF is
+not connected. One consequence is pulseaudio failing to load bluetooth
+module.
+---
+ audio/main.c |    9 +++++++--
+ 1 file changed, 7 insertions(+), 2 deletions(-)
+
+diff --git a/audio/main.c b/audio/main.c
+index 5c751af..a48c8b8 100644
+--- a/audio/main.c
++++ b/audio/main.c
+@@ -102,7 +102,7 @@ static void sco_server_cb(GIOChannel *chan, GError *err, gpointer data)
+ 	if (device->headset) {
+ 		if (headset_get_state(device) < HEADSET_STATE_CONNECTED) {
+ 			DBG("Refusing SCO from non-connected headset");
+-			goto drop;
++			goto gateway;
+ 		}
+ 
+ 		if (!headset_get_hfp_active(device)) {
+@@ -115,7 +115,11 @@ static void sco_server_cb(GIOChannel *chan, GError *err, gpointer data)
+ 			goto drop;
+ 
+ 		headset_set_state(device, HEADSET_STATE_PLAYING);
+-	} else if (device->gateway) {
++		goto connect;
++	}
++
++gateway:
++	if (device->gateway) {
+ 		if (!gateway_is_connected(device)) {
+ 			DBG("Refusing SCO from non-connected AG");
+ 			goto drop;
+@@ -126,6 +130,7 @@ static void sco_server_cb(GIOChannel *chan, GError *err, gpointer data)
+ 	} else
+ 		goto drop;
+ 
++connect:
+ 	sk = g_io_channel_unix_get_fd(chan);
+ 	fcntl(sk, F_SETFL, 0);
+ 
+-- 
diff --git a/debian/patches/0011-Fix-GDBus-flags-after-conversion-to-macros.patch b/debian/patches/0011-Fix-GDBus-flags-after-conversion-to-macros.patch
new file mode 100644
index 0000000..49df1bb
--- /dev/null
+++ b/debian/patches/0011-Fix-GDBus-flags-after-conversion-to-macros.patch
@@ -0,0 +1,81 @@
+From: Lucas De Marchi <lucas.demarchi@profusion.mobi>
+Date: Tue, 26 Jun 2012 18:11:25 -0300
+Subject: Fix GDBus flags after conversion to macros
+
+Commit "aa3b9016bf444b60e1b7e1804dfc323a23a93c5a Convert GDBus methods
+to use macro helpers" converted the previous tables to use the new
+macros but some flags were lost.
+---
+ attrib/client.c   |    2 +-
+ audio/control.c   |    2 +-
+ audio/headset.c   |    2 +-
+ audio/transport.c |    2 +-
+ src/manager.c     |    2 +-
+ 5 files changed, 5 insertions(+), 5 deletions(-)
+
+diff --git a/attrib/client.c b/attrib/client.c
+index 8d119df..b3e3abe 100644
+--- a/attrib/client.c
++++ b/attrib/client.c
+@@ -519,7 +519,7 @@ static const GDBusMethodTable char_methods[] = {
+ 	{ GDBUS_METHOD("GetProperties",
+ 			NULL, GDBUS_ARGS({ "properties", "a{sv}" }),
+ 			get_properties) },
+-	{ GDBUS_METHOD("SetProperty",
++	{ GDBUS_ASYNC_METHOD("SetProperty",
+ 			GDBUS_ARGS({ "name", "s" }, { "value", "v" }), NULL,
+ 			set_property) },
+ 	{ }
+diff --git a/audio/control.c b/audio/control.c
+index c5a6a58..187f838 100644
+--- a/audio/control.c
++++ b/audio/control.c
+@@ -198,7 +198,7 @@ static DBusMessage *control_get_properties(DBusConnection *conn,
+ }
+ 
+ static const GDBusMethodTable control_methods[] = {
+-	{ GDBUS_ASYNC_METHOD("IsConnected",
++	{ GDBUS_DEPRECATED_METHOD("IsConnected",
+ 				NULL, GDBUS_ARGS({ "connected", "b" }),
+ 				control_is_connected) },
+ 	{ GDBUS_METHOD("GetProperties",
+diff --git a/audio/headset.c b/audio/headset.c
+index 729e4dc..b9c6265 100644
+--- a/audio/headset.c
++++ b/audio/headset.c
+@@ -2094,7 +2094,7 @@ static const GDBusMethodTable headset_methods[] = {
+ static const GDBusSignalTable headset_signals[] = {
+ 	{ GDBUS_DEPRECATED_SIGNAL("Connected", NULL) },
+ 	{ GDBUS_DEPRECATED_SIGNAL("Disconnected", NULL) },
+-	{ GDBUS_DEPRECATED_SIGNAL("AnswerRequested", NULL) },
++	{ GDBUS_SIGNAL("AnswerRequested", NULL) },
+ 	{ GDBUS_DEPRECATED_SIGNAL("Stopped", NULL) },
+ 	{ GDBUS_DEPRECATED_SIGNAL("Playing", NULL) },
+ 	{ GDBUS_DEPRECATED_SIGNAL("SpeakerGainChanged",
+diff --git a/audio/transport.c b/audio/transport.c
+index b015625..832ad2a 100644
+--- a/audio/transport.c
++++ b/audio/transport.c
+@@ -959,7 +959,7 @@ static const GDBusMethodTable transport_methods[] = {
+ 	{ GDBUS_ASYNC_METHOD("Release",
+ 			GDBUS_ARGS({ "access_type", "s" }), NULL,
+ 			release ) },
+-	{ GDBUS_ASYNC_METHOD("SetProperty",
++	{ GDBUS_METHOD("SetProperty",
+ 			GDBUS_ARGS({ "name", "s" }, { "value", "v" }),
+ 			NULL, set_property) },
+ 	{ },
+diff --git a/src/manager.c b/src/manager.c
+index 385354d..7061f64 100644
+--- a/src/manager.c
++++ b/src/manager.c
+@@ -207,7 +207,7 @@ static const GDBusMethodTable manager_methods[] = {
+ 			GDBUS_ARGS({ "pattern", "s" }),
+ 			GDBUS_ARGS({ "adapter", "o" }),
+ 			find_adapter) },
+-	{ GDBUS_ASYNC_METHOD("ListAdapters",
++	{ GDBUS_DEPRECATED_METHOD("ListAdapters",
+ 			NULL, GDBUS_ARGS({ "adapters", "ao" }),
+ 			list_adapters) },
+ 	{ }
+-- 
diff --git a/debian/patches/0012-network-NULL-dereference-fix.patch b/debian/patches/0012-network-NULL-dereference-fix.patch
new file mode 100644
index 0000000..b8b4b44
--- /dev/null
+++ b/debian/patches/0012-network-NULL-dereference-fix.patch
@@ -0,0 +1,31 @@
+From: Pavel Raiskup <praiskup@redhat.com>
+Date: Tue, 30 Aug 2011 15:10:46 +0200
+Subject: network: NULL dereference fix
+
+Variable ifindex dereferenced on line 242 before null check on line 249.
+---
+ network/common.c |    4 +++-
+ 1 file changed, 3 insertions(+), 1 deletion(-)
+
+diff --git a/network/common.c b/network/common.c
+index 4704072..a223685 100644
+--- a/network/common.c
++++ b/network/common.c
+@@ -240,13 +240,15 @@ int bnep_if_down(const char *devname)
+ 
+ int bnep_add_to_bridge(const char *devname, const char *bridge)
+ {
+-	int ifindex = if_nametoindex(devname);
++	int ifindex;
+ 	struct ifreq ifr;
+ 	int sk, err;
+ 
+ 	if (!devname || !bridge)
+ 		return -EINVAL;
+ 
++	ifindex = if_nametoindex(devname);
++
+ 	sk = socket(AF_INET, SOCK_STREAM, 0);
+ 	if (sk < 0)
+ 		return -1;
+-- 
diff --git a/debian/patches/0013-input-Fix-not-adding-watches-when-io-channel-is-conn.patch b/debian/patches/0013-input-Fix-not-adding-watches-when-io-channel-is-conn.patch
new file mode 100644
index 0000000..3f43e81
--- /dev/null
+++ b/debian/patches/0013-input-Fix-not-adding-watches-when-io-channel-is-conn.patch
@@ -0,0 +1,98 @@
+From: Luiz Augusto von Dentz <luiz.von.dentz@intel.com>
+Date: Tue, 19 Jun 2012 12:44:43 +0300
+Subject: input: Fix not adding watches when io channel is connected
+
+This can leave dangling pointers in case one of the channel is never
+connected which cause -EALREADY to be returned by
+input_device_set_channel next time the device attempts to connect.
+
+For the same reason the code path when acting as client now add the
+watch as soon as the connection completes instead when both channels
+are connected.
+---
+ input/device.c |   31 ++++++++++++++++++++++++-------
+ 1 file changed, 24 insertions(+), 7 deletions(-)
+
+diff --git a/input/device.c b/input/device.c
+index 0e3f4a9..09a9a39 100644
+--- a/input/device.c
++++ b/input/device.c
+@@ -387,6 +387,11 @@ static gboolean intr_watch_cb(GIOChannel *chan, GIOCondition cond, gpointer data
+ 	struct input_conn *iconn = data;
+ 	struct input_device *idev = iconn->idev;
+ 	gboolean connected = FALSE;
++	char address[18];
++
++	ba2str(&iconn->idev->dst, address);
++
++	DBG("Device %s disconnected", address);
+ 
+ 	/* Checking for ctrl_watch avoids a double g_io_channel_shutdown since
+ 	 * it's likely that ctrl_watch_cb has been queued for dispatching in
+@@ -415,6 +420,11 @@ static gboolean intr_watch_cb(GIOChannel *chan, GIOCondition cond, gpointer data
+ static gboolean ctrl_watch_cb(GIOChannel *chan, GIOCondition cond, gpointer data)
+ {
+ 	struct input_conn *iconn = data;
++	char address[18];
++
++	ba2str(&iconn->idev->dst, address);
++
++	DBG("Device %s disconnected", address);
+ 
+ 	/* Checking for intr_watch avoids a double g_io_channel_shutdown since
+ 	 * it's likely that intr_watch_cb has been queued for dispatching in
+@@ -811,13 +821,6 @@ static int input_device_connected(struct input_device *idev,
+ 	if (err < 0)
+ 		return err;
+ 
+-	iconn->intr_watch = g_io_add_watch(iconn->intr_io,
+-					G_IO_HUP | G_IO_ERR | G_IO_NVAL,
+-					intr_watch_cb, iconn);
+-	iconn->ctrl_watch = g_io_add_watch(iconn->ctrl_io,
+-					G_IO_HUP | G_IO_ERR | G_IO_NVAL,
+-					ctrl_watch_cb, iconn);
+-
+ 	connected = TRUE;
+ 	emit_property_changed(idev->conn, idev->path, INPUT_DEVICE_INTERFACE,
+ 				"Connected", DBUS_TYPE_BOOLEAN, &connected);
+@@ -854,6 +857,10 @@ static void interrupt_connect_cb(GIOChannel *chan, GError *conn_err,
+ 	dbus_message_unref(iconn->pending_connect);
+ 	iconn->pending_connect = NULL;
+ 
++	iconn->intr_watch = g_io_add_watch(iconn->intr_io,
++					G_IO_HUP | G_IO_ERR | G_IO_NVAL,
++					intr_watch_cb, iconn);
++
+ 	return;
+ 
+ failed:
+@@ -913,6 +920,10 @@ static void control_connect_cb(GIOChannel *chan, GError *conn_err,
+ 
+ 	iconn->intr_io = io;
+ 
++	iconn->ctrl_watch = g_io_add_watch(iconn->ctrl_io,
++					G_IO_HUP | G_IO_ERR | G_IO_NVAL,
++					ctrl_watch_cb, iconn);
++
+ 	return;
+ 
+ failed:
+@@ -1272,11 +1283,17 @@ int input_device_set_channel(const bdaddr_t *src, const bdaddr_t *dst, int psm,
+ 		if (iconn->ctrl_io)
+ 			return -EALREADY;
+ 		iconn->ctrl_io = g_io_channel_ref(io);
++		iconn->ctrl_watch = g_io_add_watch(iconn->ctrl_io,
++					G_IO_HUP | G_IO_ERR | G_IO_NVAL,
++					ctrl_watch_cb, iconn);
+ 		break;
+ 	case L2CAP_PSM_HIDP_INTR:
+ 		if (iconn->intr_io)
+ 			return -EALREADY;
+ 		iconn->intr_io = g_io_channel_ref(io);
++		iconn->intr_watch = g_io_add_watch(iconn->intr_io,
++					G_IO_HUP | G_IO_ERR | G_IO_NVAL,
++					intr_watch_cb, iconn);
+ 		break;
+ 	}
+ 
+-- 
diff --git a/debian/patches/0014-True-volume-control-3859147d82.diff.patch b/debian/patches/0014-True-volume-control-3859147d82.diff.patch
new file mode 100644
index 0000000..9c2a0fe
--- /dev/null
+++ b/debian/patches/0014-True-volume-control-3859147d82.diff.patch
@@ -0,0 +1,123 @@
+From: Nathaniel Abalos <ncabalos@truefitness.com>
+Date: Thu, 29 May 2014 13:35:57 -0500
+Subject: True-volume-control-3859147d82.diff
+
+---
+ audio/control.c |   62 ++++++++++++++++++++++++++++++++++++++++++-------------
+ audio/device.c  |    2 +-
+ 2 files changed, 49 insertions(+), 15 deletions(-)
+
+diff --git a/audio/control.c b/audio/control.c
+index 187f838..7555225 100644
+--- a/audio/control.c
++++ b/audio/control.c
+@@ -128,8 +128,8 @@ static DBusMessage *control_is_connected(DBusConnection *conn,
+ 	return reply;
+ }
+ 
+-static DBusMessage *volume_up(DBusConnection *conn, DBusMessage *msg,
+-								void *data)
++static DBusMessage *internal_send_passthrough(DBusConnection *conn, 
++					DBusMessage *msg, void *data, uint8_t op)
+ {
+ 	struct audio_device *device = data;
+ 	struct control *control = device->control;
+@@ -141,31 +141,59 @@ static DBusMessage *volume_up(DBusConnection *conn, DBusMessage *msg,
+ 	if (!control->target)
+ 		return btd_error_not_supported(msg);
+ 
+-	err = avctp_send_passthrough(control->session, VOL_UP_OP);
++	err = avctp_send_passthrough(control->session, op);
+ 	if (err < 0)
+ 		return btd_error_failed(msg, strerror(-err));
+ 
+ 	return dbus_message_new_method_return(msg);
+ }
+ 
++static DBusMessage *volume_up(DBusConnection *conn, DBusMessage *msg,
++								void *data)
++{
++	return internal_send_passthrough(conn, msg, data, VOL_UP_OP);
++}
++
+ static DBusMessage *volume_down(DBusConnection *conn, DBusMessage *msg,
+ 								void *data)
+ {
+-	struct audio_device *device = data;
+-	struct control *control = device->control;
+-	int err;
++	return internal_send_passthrough(conn, msg, data, VOL_DOWN_OP);
++}
+ 
+-	if (!control->session)
+-		return btd_error_not_connected(msg);
++static DBusMessage *control_play(DBusConnection *conn, DBusMessage *msg,
++								void *data)
++{
++	return internal_send_passthrough(conn, msg, data, PLAY_OP);
++}
+ 
+-	if (!control->target)
+-		return btd_error_not_supported(msg);
++static DBusMessage *control_pause(DBusConnection *conn, DBusMessage *msg,
++								void *data)
++{
++	return internal_send_passthrough(conn, msg, data, PAUSE_OP);
++}
+ 
+-	err = avctp_send_passthrough(control->session, VOL_DOWN_OP);
+-	if (err < 0)
+-		return btd_error_failed(msg, strerror(-err));
++static DBusMessage *control_stop(DBusConnection *conn, DBusMessage *msg,
++								void *data)
++{
++	return internal_send_passthrough(conn, msg, data, STAVC_OP_OP);
++}
+ 
+-	return dbus_message_new_method_return(msg);
++static DBusMessage *control_forward(DBusConnection *conn, DBusMessage *msg,
++								void *data)
++{
++	return internal_send_passthrough(conn, msg, data, FORWARD_OP);
++}
++
++static DBusMessage *control_backward(DBusConnection *conn, DBusMessage *msg,
++								void *data)
++{
++	return internal_send_passthrough(conn, msg, data, BACKWARD_OP);
++}
++
++static DBusMessage *control_mute(DBusConnection *conn, DBusMessage *msg,
++								void *data)
++{
++	return internal_send_passthrough(conn, msg, data, MUTE_OP);
+ }
+ 
+ static DBusMessage *control_get_properties(DBusConnection *conn,
+@@ -206,6 +234,12 @@ static const GDBusMethodTable control_methods[] = {
+ 				control_get_properties) },
+ 	{ GDBUS_METHOD("VolumeUp", NULL, NULL, volume_up) },
+ 	{ GDBUS_METHOD("VolumeDown", NULL, NULL, volume_down) },
++	{ GDBUS_METHOD("Play", NULL, NULL, control_play) },
++	{ GDBUS_METHOD("Stop", NULL, NULL, control_stop) },
++	{ GDBUS_METHOD("Pause", NULL, NULL, control_pause) },
++	{ GDBUS_METHOD("Forward", NULL, NULL, control_forward) },
++	{ GDBUS_METHOD("Backward", NULL, NULL, control_backward) },	
++	{ GDBUS_METHOD("Mute", NULL, NULL, control_mute) },
+ 	{ }
+ };
+ 
+diff --git a/audio/device.c b/audio/device.c
+index b7b993e..1ecbc9b 100644
+--- a/audio/device.c
++++ b/audio/device.c
+@@ -369,7 +369,7 @@ static void device_avdtp_cb(struct audio_device *dev, struct avdtp *session,
+ 				avdtp_session_state_t new_state,
+ 				void *user_data)
+ {
+-	if (!dev->sink || !dev->control)
++	if (!dev->control)
+ 		return;
+ 
+ 	if (new_state == AVDTP_SESSION_STATE_CONNECTED) {
+-- 
diff --git a/debian/patches/0015-True-Updated-control-api.txt-file.patch b/debian/patches/0015-True-Updated-control-api.txt-file.patch
new file mode 100644
index 0000000..ca8476f
--- /dev/null
+++ b/debian/patches/0015-True-Updated-control-api.txt-file.patch
@@ -0,0 +1,44 @@
+From: Nathaniel Cabalos <ncabalos@truefitness.com>
+Date: Thu, 29 May 2014 13:35:57 -0500
+Subject: True-Updated-control-api.txt-file.patch
+
+---
+ doc/control-api.txt |   24 ++++++++++++++++++++++++
+ 1 file changed, 24 insertions(+)
+
+diff --git a/doc/control-api.txt b/doc/control-api.txt
+index eacfbcd..5a2c62e 100644
+--- a/doc/control-api.txt
++++ b/doc/control-api.txt
+@@ -29,6 +29,30 @@ Methods		boolean IsConnected() {deprecated}
+ 
+ 			Adjust remote volume one step down
+ 
++		void Play()
++			
++			Play track
++
++		void Stop()
++
++			Stop track
++
++		void Pause()
++		
++			Pause track
++
++		void Forward()
++
++			Next track
++
++		void Backward()
++
++			Previous track
++
++		void Mute()
++	
++			Mute volume
++
+ Signals		Connected() {deprecated}
+ 
+ 			Sent when a successful AVRCP connection has been made
+-- 
diff --git a/debian/patches/0016-True-Bluetooth-metadata.patch b/debian/patches/0016-True-Bluetooth-metadata.patch
new file mode 100644
index 0000000..0af668e
--- /dev/null
+++ b/debian/patches/0016-True-Bluetooth-metadata.patch
@@ -0,0 +1,917 @@
+From: Nathaniel Cabalos <ncabalos@truefitness.com>
+Date: Mon, 10 Feb 2014 13:35:57 -0500
+Subject: True-Bluetooth-metadata
+
+---
+ audio/avctp.c   |   50 ++++--
+ audio/avctp.h   |    1 +
+ audio/avrcp.c   |  471 +++++++++++++++++++++++++++++++++++++++++++++++++++----
+ audio/avrcp.h   |   26 ++-
+ audio/control.c |   40 ++++-
+ audio/control.h |    7 +
+ lib/sdp.h       |    1 +
+ 7 files changed, 540 insertions(+), 56 deletions(-)
+
+diff --git a/audio/avctp.c b/audio/avctp.c
+index ae3c04e..26f7fbe 100644
+--- a/audio/avctp.c
++++ b/audio/avctp.c
+@@ -412,23 +412,30 @@ static void handle_response(struct avctp *session, struct avctp_header *avctp,
+ 				size_t operand_count)
+ {
+ 	GSList *l;
+-
++	/* 
++	 * Ignore passthrough command rsponses because it messes up
++	 * the transaction id numbering
++	 */
++	if(avc->code == 0x09 && avc->opcode == 0x7C){
++		return;
++	}
++	
+ 	for (l = session->handlers; l; l = l->next) {
+ 		struct avctp_rsp_handler *handler = l->data;
+-
++		
+ 		if (handler->id != avctp->transaction)
+ 			continue;
+ 
+ 		if (handler->func && handler->func(session, avc->code,
+-						avc->subunit_type,
+-						operands, operand_count,
+-						handler->user_data))
+-			return;
+-
++					avc->subunit_type,
++					operands, operand_count,
++					handler->user_data))
++				return;
++				
+ 		session->handlers = g_slist_remove(session->handlers, handler);
+ 		g_free(handler);
+-
+-		return;
++			
++		return;			
+ 	}
+ }
+ 
+@@ -900,7 +907,7 @@ int avctp_send_passthrough(struct avctp *session, uint8_t op)
+ 
+ 	memset(buf, 0, sizeof(buf));
+ 
+-	avctp->transaction = id++;
++	avctp->transaction = id;
+ 	avctp->packet_type = AVCTP_PACKET_SINGLE;
+ 	avctp->cr = AVCTP_COMMAND;
+ 	avctp->pid = htons(AV_REMOTE_SVCLASS_ID);
+@@ -916,14 +923,21 @@ int avctp_send_passthrough(struct avctp *session, uint8_t op)
+ 
+ 	if (write(sk, buf, sizeof(buf)) < 0)
+ 		return -errno;
+-
++	DBG("Passthru Press send with id: %d", id);
++	id++;
++	id %= 16;
++	
+ 	/* Button release */
+-	avctp->transaction = id++;
++	avctp->transaction = id;
++	
+ 	operands[0] |= 0x80;
+ 
+ 	if (write(sk, buf, sizeof(buf)) < 0)
+ 		return -errno;
+-
++	DBG("Passthru Release send with id: %d", id);
++	id++;
++	id %= 16;
++	
+ 	return 0;
+ }
+ 
+@@ -964,6 +978,7 @@ static int avctp_send(struct avctp *session, uint8_t transaction, uint8_t cr,
+ 		err = -errno;
+ 
+ 	g_free(buf);
++	DBG("Vendor send with id: %d", transaction);
+ 	return err;
+ }
+ 
+@@ -985,8 +1000,10 @@ int avctp_send_vendordep_req(struct avctp *session, uint8_t code,
+ 
+ 	err = avctp_send(session, id, AVCTP_COMMAND, code, subunit,
+ 				AVC_OP_VENDORDEP, operands, operand_count);
+-	if (err < 0)
++	if (err < 0){
++		DBG("Vendor send error: %d",err);
+ 		return err;
++	}
+ 
+ 	handler = g_new0(struct avctp_rsp_handler, 1);
+ 	handler->id = id;
+@@ -994,9 +1011,11 @@ int avctp_send_vendordep_req(struct avctp *session, uint8_t code,
+ 	handler->user_data = user_data;
+ 
+ 	session->handlers = g_slist_prepend(session->handlers, handler);
+-
++	
+ 	id++;
++	id %= 16; //transaction id is only 4 bits
+ 
++	
+ 	return 0;
+ }
+ 
+@@ -1075,6 +1094,7 @@ struct avctp *avctp_connect(const bdaddr_t *src, const bdaddr_t *dst)
+ 	GError *err = NULL;
+ 	GIOChannel *io;
+ 
++	DBG("src: %s, dst: %s", batostr(src),batostr(dst));
+ 	session = avctp_get_internal(src, dst);
+ 	if (!session)
+ 		return NULL;
+diff --git a/audio/avctp.h b/audio/avctp.h
+index d0cbd97..3ecdada 100644
+--- a/audio/avctp.h
++++ b/audio/avctp.h
+@@ -23,6 +23,7 @@
+  */
+ 
+ #define AVCTP_PSM 23
++#define AVCTP_BROWSING_PSM		27
+ 
+ #define AVC_MTU 512
+ #define AVC_HEADER_LENGTH 3
+diff --git a/audio/avrcp.c b/audio/avrcp.c
+index 89ee112..6a81ae3 100644
+--- a/audio/avrcp.c
++++ b/audio/avrcp.c
+@@ -57,6 +57,7 @@
+ #include "avrcp.h"
+ #include "sdpd.h"
+ #include "dbus-common.h"
++#include "control.h"
+ 
+ /* Company IDs for vendor dependent commands */
+ #define IEEEID_BTSIG		0x001958
+@@ -95,12 +96,14 @@
+ #define CAP_EVENTS_SUPPORTED	0x03
+ 
+ #define AVRCP_REGISTER_NOTIFICATION_PARAM_LENGTH 5
++#define AVRCP_GET_CAPABILITIES_PARAM_LENGTH 1
+ 
+ #define AVRCP_FEATURE_CATEGORY_1	0x0001
+ #define AVRCP_FEATURE_CATEGORY_2	0x0002
+ #define AVRCP_FEATURE_CATEGORY_3	0x0004
+ #define AVRCP_FEATURE_CATEGORY_4	0x0008
+ #define AVRCP_FEATURE_PLAYER_SETTINGS	0x0010
++#define AVRCP_FEATURE_BROWSING			0x0040
+ 
+ enum battery_status {
+ 	BATTERY_STATUS_NORMAL =		0,
+@@ -147,6 +150,7 @@ struct avrcp_server {
+ 	uint32_t ct_record_id;
+ 	GSList *players;
+ 	struct avrcp_player *active_player;
++	struct avctp *session;
+ };
+ 
+ struct pending_pdu {
+@@ -170,6 +174,13 @@ struct avrcp_player {
+ 	GDestroyNotify destroy;
+ };
+ 
++struct avrcp_state_callback {
++	avrcp_state_cb cb;
++	void *user_data;
++	unsigned int id;
++};
++
++static GSList *callbacks = NULL;
+ static GSList *servers = NULL;
+ static unsigned int avctp_id = 0;
+ 
+@@ -179,71 +190,97 @@ static uint32_t company_ids[] = {
+ };
+ 
+ static void register_volume_notification(struct avrcp_player *player);
++static void avrcp_register_notification(struct control *con, uint8_t event);
++static void avrcp_get_element_attributes(struct control *con);
++
+ 
+ static sdp_record_t *avrcp_ct_record(void)
+ {
+-	sdp_list_t *svclass_id, *pfseq, *apseq, *root;
+-	uuid_t root_uuid, l2cap, avctp, avrct;
++	sdp_list_t *svclass_id, *pfseq, *apseq, *apseq1, *root;
++	uuid_t root_uuid, l2cap, avctp, avrct, avrctr;
+ 	sdp_profile_desc_t profile[1];
+-	sdp_list_t *aproto, *proto[2];
++	sdp_list_t *aproto, *aproto1, *proto[2], *proto1[2];
+ 	sdp_record_t *record;
+-	sdp_data_t *psm, *version, *features;
+-	uint16_t lp = AVCTP_PSM;
+-	uint16_t avrcp_ver = 0x0100, avctp_ver = 0x0103;
++	sdp_data_t *psm[2], *version, *features;
++	uint16_t lp = AVCTP_PSM, ap = AVCTP_BROWSING_PSM;
++	uint16_t avrcp_ver = 0x0105, avctp_ver = 0x0103;
+ 	uint16_t feat = ( AVRCP_FEATURE_CATEGORY_1 |
+ 						AVRCP_FEATURE_CATEGORY_2 |
+ 						AVRCP_FEATURE_CATEGORY_3 |
+-						AVRCP_FEATURE_CATEGORY_4 );
++						AVRCP_FEATURE_CATEGORY_4 |
++						AVRCP_FEATURE_BROWSING);
+ 
+ 	record = sdp_record_alloc();
+ 	if (!record)
+ 		return NULL;
+ 
+ 	sdp_uuid16_create(&root_uuid, PUBLIC_BROWSE_GROUP);
+-	root = sdp_list_append(0, &root_uuid);
++	root = sdp_list_append(NULL, &root_uuid);
+ 	sdp_set_browse_groups(record, root);
+ 
+ 	/* Service Class ID List */
+ 	sdp_uuid16_create(&avrct, AV_REMOTE_SVCLASS_ID);
+-	svclass_id = sdp_list_append(0, &avrct);
++	svclass_id = sdp_list_append(NULL, &avrct);
++	sdp_uuid16_create(&avrctr, AV_REMOTE_CONTROLLER_SVCLASS_ID);
++	svclass_id = sdp_list_append(svclass_id, &avrctr);
+ 	sdp_set_service_classes(record, svclass_id);
+ 
+ 	/* Protocol Descriptor List */
+ 	sdp_uuid16_create(&l2cap, L2CAP_UUID);
+-	proto[0] = sdp_list_append(0, &l2cap);
+-	psm = sdp_data_alloc(SDP_UINT16, &lp);
+-	proto[0] = sdp_list_append(proto[0], psm);
+-	apseq = sdp_list_append(0, proto[0]);
++	proto[0] = sdp_list_append(NULL, &l2cap);
++	psm[0] = sdp_data_alloc(SDP_UINT16, &lp);
++	proto[0] = sdp_list_append(proto[0], psm[0]);
++	apseq = sdp_list_append(NULL, proto[0]);
+ 
+ 	sdp_uuid16_create(&avctp, AVCTP_UUID);
+-	proto[1] = sdp_list_append(0, &avctp);
++	proto[1] = sdp_list_append(NULL, &avctp);
+ 	version = sdp_data_alloc(SDP_UINT16, &avctp_ver);
+ 	proto[1] = sdp_list_append(proto[1], version);
+ 	apseq = sdp_list_append(apseq, proto[1]);
+ 
+-	aproto = sdp_list_append(0, apseq);
++	aproto = sdp_list_append(NULL, apseq);
+ 	sdp_set_access_protos(record, aproto);
+ 
++	/* Additional Protocol Descriptor List */
++	sdp_uuid16_create(&l2cap, L2CAP_UUID);
++	proto1[0] = sdp_list_append(NULL, &l2cap);
++	psm[1] = sdp_data_alloc(SDP_UINT16, &ap);
++	proto1[0] = sdp_list_append(proto1[0], psm[1]);
++	apseq1 = sdp_list_append(NULL, proto1[0]);
++
++	sdp_uuid16_create(&avctp, AVCTP_UUID);
++	proto1[1] = sdp_list_append(NULL, &avctp);
++	proto1[1] = sdp_list_append(proto1[1], version);
++	apseq1 = sdp_list_append(apseq1, proto1[1]);
++
++	aproto1 = sdp_list_append(NULL, apseq1);
++	sdp_set_add_access_protos(record, aproto1);
++
+ 	/* Bluetooth Profile Descriptor List */
+ 	sdp_uuid16_create(&profile[0].uuid, AV_REMOTE_PROFILE_ID);
+ 	profile[0].version = avrcp_ver;
+-	pfseq = sdp_list_append(0, &profile[0]);
++	pfseq = sdp_list_append(NULL, &profile[0]);
+ 	sdp_set_profile_descs(record, pfseq);
+ 
+ 	features = sdp_data_alloc(SDP_UINT16, &feat);
+ 	sdp_attr_add(record, SDP_ATTR_SUPPORTED_FEATURES, features);
+ 
+-	sdp_set_info_attr(record, "AVRCP CT", 0, 0);
++	sdp_set_info_attr(record, "AVRCP CT", NULL, NULL);
+ 
+-	free(psm);
++	free(psm[0]);
++	free(psm[1]);
+ 	free(version);
+-	sdp_list_free(proto[0], 0);
+-	sdp_list_free(proto[1], 0);
+-	sdp_list_free(apseq, 0);
+-	sdp_list_free(pfseq, 0);
+-	sdp_list_free(aproto, 0);
+-	sdp_list_free(root, 0);
+-	sdp_list_free(svclass_id, 0);
++	sdp_list_free(proto[0], NULL);
++	sdp_list_free(proto[1], NULL);
++	sdp_list_free(apseq, NULL);
++	sdp_list_free(proto1[0], NULL);
++	sdp_list_free(proto1[1], NULL);
++	sdp_list_free(aproto1, NULL);
++	sdp_list_free(apseq1, NULL);
++	sdp_list_free(pfseq, NULL);
++	sdp_list_free(aproto, NULL);
++	sdp_list_free(root, NULL);
++	sdp_list_free(svclass_id, NULL);
+ 
+ 	return record;
+ }
+@@ -1132,6 +1169,7 @@ size_t avrcp_handle_vendor_reject(uint8_t *code, uint8_t *operands)
+ 
+ static struct avrcp_server *find_server(GSList *list, const bdaddr_t *src)
+ {
++	DBG("Finding server for: %s", batostr(src));
+ 	for (; list; list = list->next) {
+ 		struct avrcp_server *server = list->data;
+ 
+@@ -1196,6 +1234,7 @@ static void state_changed(struct audio_device *dev, avctp_state_t old_state,
+ 	sdp_list_t *list;
+ 	sdp_profile_desc_t *desc;
+ 
++	
+ 	server = find_server(servers, &dev->src);
+ 	if (!server)
+ 		return;
+@@ -1217,6 +1256,8 @@ static void state_changed(struct audio_device *dev, avctp_state_t old_state,
+ 
+ 		break;
+ 	case AVCTP_STATE_CONNECTING:
++		DBG("new state: Connecting");
++		//avrcp_get_capabilities(dev);
+ 		player->session = avctp_connect(&dev->src, &dev->dst);
+ 		player->dev = dev;
+ 
+@@ -1227,6 +1268,7 @@ static void state_changed(struct audio_device *dev, avctp_state_t old_state,
+ 							player);
+ 		break;
+ 	case AVCTP_STATE_CONNECTED:
++		DBG("AVCTP Connected******************");
+ 		rec = btd_device_get_record(dev->btd_dev, AVRCP_TARGET_UUID);
+ 		if (rec == NULL)
+ 			return;
+@@ -1236,8 +1278,9 @@ static void state_changed(struct audio_device *dev, avctp_state_t old_state,
+ 
+ 		desc = list->data;
+ 
+-		if (desc && desc->version >= 0x0104)
++		if (desc && desc->version >= 0x0104){
+ 			register_volume_notification(player);
++		}
+ 
+ 		sdp_list_free(list, free);
+ 	default:
+@@ -1247,12 +1290,22 @@ static void state_changed(struct audio_device *dev, avctp_state_t old_state,
+ 
+ gboolean avrcp_connect(struct audio_device *dev)
+ {
++	struct avrcp_server *server;
+ 	struct avctp *session;
+ 
+-	session = avctp_connect(&dev->src, &dev->dst);
+-	if (session)
++	DBG("Connecting to avrcp...");
++	server = find_server(servers, &dev->src);
++	if (server == NULL){
++		DBG("Server not found");
+ 		return FALSE;
++	}
+ 
++	session = avctp_connect(&dev->src, &dev->dst);
++	if (session){
++		DBG("Connecting to avrcp failed");
++		return FALSE;
++	}
++	DBG("Connecting to avrcp success...");
+ 	return TRUE;
+ }
+ 
+@@ -1466,3 +1519,365 @@ int avrcp_set_volume(struct audio_device *dev, uint8_t volume)
+ 					AVC_SUBUNIT_PANEL, buf, sizeof(buf),
+ 					avrcp_handle_set_volume, player);
+ }
++
++static gboolean avrcp_get_capabilities_resp(struct avctp *conn,
++					uint8_t code, uint8_t subunit,
++					uint8_t *operands, size_t operand_count,
++					void *user_data)
++{
++	struct control *control_ptr = user_data;
++	struct avrcp_header *pdu = (void *) operands;
++	uint16_t events = 0;
++	uint8_t count;
++
++	if (pdu == NULL || pdu->params[0] != CAP_EVENTS_SUPPORTED)
++		return FALSE;
++	DBG("get capabilities response");
++	/* Connect browsing if pending */
++	/*
++	if (session->browsing_timer > 0) {
++		g_source_remove(session->browsing_timer);
++		session->browsing_timer = 0;
++		avctp_connect_browsing(session->conn);
++	}
++	*/
++	count = pdu->params[1];
++
++	for (; count > 0; count--) {
++		uint8_t event = pdu->params[1 + count];
++
++		events |= (1 << event);
++
++		switch (event) {
++		case AVRCP_EVENT_STATUS_CHANGED:
++		case AVRCP_EVENT_TRACK_CHANGED:
++		//case AVRCP_EVENT_SETTINGS_CHANGED:
++		//case AVRCP_EVENT_ADDRESSED_PLAYER_CHANGED:
++		//case AVRCP_EVENT_UIDS_CHANGED:
++		//case AVRCP_EVENT_AVAILABLE_PLAYERS_CHANGED:
++		//case AVRCP_EVENT_VOLUME_CHANGED:
++			DBG("Event Supported: %d", event);
++			avrcp_register_notification(control_ptr, event);
++			break;
++		}
++	}
++	/*
++	if (!(events & (1 << AVRCP_EVENT_SETTINGS_CHANGED)))
++		avrcp_list_player_attributes(session);
++
++	if (!(events & (1 << AVRCP_EVENT_STATUS_CHANGED)))
++		avrcp_get_play_status(session);
++    */
++	if (!(events & (1 << AVRCP_EVENT_STATUS_CHANGED)))
++		avrcp_get_element_attributes(control_ptr);
++
++	return TRUE;
++}
++ 
++void avrcp_get_capabilities(struct control *con)
++{
++	uint8_t buf[AVRCP_HEADER_LENGTH + AVRCP_GET_CAPABILITIES_PARAM_LENGTH];
++	struct avrcp_header *pdu = (void *) buf;
++	uint8_t length;
++	
++
++	if (con->session == NULL)
++		return;
++
++	memset(buf, 0, sizeof(buf));
++
++	set_company_id(pdu->company_id, IEEEID_BTSIG);
++	pdu->pdu_id = AVRCP_GET_CAPABILITIES;
++	pdu->packet_type = AVRCP_PACKET_TYPE_SINGLE;
++	pdu->params[0] = CAP_EVENTS_SUPPORTED;
++	pdu->params_len = htons(AVRCP_GET_CAPABILITIES_PARAM_LENGTH);
++
++	length = AVRCP_HEADER_LENGTH + ntohs(pdu->params_len);
++	DBG("Getting caps for session: %p", con->session);
++	avctp_send_vendordep_req(con->session, AVC_CTYPE_STATUS,
++					AVC_SUBUNIT_PANEL, buf, length,
++					avrcp_get_capabilities_resp,
++					con);
++}
++
++static const char *metadata_to_str(uint32_t id)
++{
++	switch (id) {
++	case AVRCP_MEDIA_ATTRIBUTE_TITLE:
++		return "Title";
++	case AVRCP_MEDIA_ATTRIBUTE_ARTIST:
++		return "Artist";
++	case AVRCP_MEDIA_ATTRIBUTE_ALBUM:
++		return "Album";
++	case AVRCP_MEDIA_ATTRIBUTE_GENRE:
++		return "Genre";
++	case AVRCP_MEDIA_ATTRIBUTE_TRACK:
++		return "TrackNumber";
++	case AVRCP_MEDIA_ATTRIBUTE_N_TRACKS:
++		return "NumberOfTracks";
++	case AVRCP_MEDIA_ATTRIBUTE_DURATION:
++		return "Duration";
++	}
++
++	return NULL;
++}
++
++void set_metadata(struct control *con,
++				struct media_item *item, const char *key,
++				void *data, size_t len)
++{
++	char *value, *curval;
++
++	value = g_strndup(data, len);
++
++	DBG("%s: %s", key, value);
++	if(con->metadata == NULL){
++		return;
++	}
++	curval = g_hash_table_lookup(con->metadata, key);
++	if (g_strcmp0(curval, value) == 0) {
++		g_free(value);
++		return;
++	}
++
++	g_hash_table_replace(con->metadata, g_strdup(key), value);
++}
++
++static void avrcp_parse_attribute_list(struct control *con,
++					uint8_t *operands, uint8_t count)
++{
++	//struct media_player *mp = player->user_data;
++	//struct media_item *item;
++	int i;
++    char *value;
++	//item = media_player_set_playlist_item(mp, player->uid);
++
++	for (i = 0; count > 0; count--) {
++		uint32_t id;
++		uint16_t charset, len;
++
++		id = bt_get_be32(&operands[i]);
++		i += sizeof(uint32_t);
++
++		charset = bt_get_be16(&operands[i]);
++		i += sizeof(uint16_t);
++
++		len = bt_get_be16(&operands[i]);
++		i += sizeof(uint16_t);
++
++		if (charset == 106) {
++			const char *key = metadata_to_str(id);
++			if (key != NULL){
++				set_metadata(con, NULL,
++							metadata_to_str(id),
++							&operands[i], len);
++			}
++		}
++
++		i += len;
++	}
++}
++
++static gboolean avrcp_get_element_attributes_rsp(struct avctp *conn,
++						uint8_t code, uint8_t subunit,
++						uint8_t *operands,
++						size_t operand_count,
++						void *user_data)
++{
++	struct control *con = user_data;
++	struct audio_device *dev;
++	GSList *l;
++	//struct avrcp_player *player = session->controller->player;
++
++	struct avrcp_header *pdu = (void *) operands;
++	uint8_t count;
++	/*con->
++	dev = manager_get_device(conn->server->src, conn->dst, FALSE);
++	if (dev == NULL) {
++		DGB("no matching audio device");
++		return FALSE;
++	}
++	* */
++
++	if (code == AVC_CTYPE_REJECTED)
++		return FALSE;
++
++	count = pdu->params[0];
++
++	if (ntohs(pdu->params_len) - 1 < count * 8) {
++		error("Invalid parameters");
++		return FALSE;
++	}
++
++	//count is number of attributes
++	
++	avrcp_parse_attribute_list(con, &pdu->params[1], count);
++	
++	// call the callback
++	for (l = callbacks; l != NULL; l = l->next) {
++		struct avrcp_state_callback *cb = l->data;
++		cb->cb(con->dev, con);
++	}
++
++	//avrcp_get_play_status(session);
++
++	return TRUE;
++}
++
++static void avrcp_get_element_attributes(struct control *con)
++{
++	uint8_t buf[AVRCP_HEADER_LENGTH + 9];
++	struct avrcp_header *pdu = (void *) buf;
++	uint16_t length;
++
++	memset(buf, 0, sizeof(buf));
++
++	set_company_id(pdu->company_id, IEEEID_BTSIG);
++	pdu->pdu_id = AVRCP_GET_ELEMENT_ATTRIBUTES;
++	pdu->params_len = htons(9);
++	pdu->packet_type = AVRCP_PACKET_TYPE_SINGLE;
++
++	length = AVRCP_HEADER_LENGTH + ntohs(pdu->params_len);
++
++	avctp_send_vendordep_req(con->session, AVC_CTYPE_STATUS,
++					AVC_SUBUNIT_PANEL, buf, length,
++					avrcp_get_element_attributes_rsp,
++					con);
++}
++
++static const char *status_to_string(uint8_t status)
++{
++	switch (status) {
++	case AVRCP_PLAY_STATUS_STOPPED:
++		return "stopped";
++	case AVRCP_PLAY_STATUS_PLAYING:
++		return "playing";
++	case AVRCP_PLAY_STATUS_PAUSED:
++		return "paused";
++	case AVRCP_PLAY_STATUS_FWD_SEEK:
++		return "forward-seek";
++	case AVRCP_PLAY_STATUS_REV_SEEK:
++		return "reverse-seek";
++	case AVRCP_PLAY_STATUS_ERROR:
++		return "error";
++	default:
++		return NULL;
++	}
++}
++
++static gboolean avrcp_handle_event(struct avctp *conn,
++					uint8_t code, uint8_t subunit,
++					uint8_t *operands, size_t operand_count,
++					void *user_data)
++{
++	struct control *session = user_data;
++	struct avrcp_header *pdu = (void *) operands;
++	const char *curval, *strval;
++	uint8_t event;
++
++	if ((code != AVC_CTYPE_INTERIM && code != AVC_CTYPE_CHANGED) ||
++								pdu == NULL)
++		return FALSE;
++
++	event = pdu->params[0];
++
++	if (code == AVC_CTYPE_CHANGED) {
++		switch (event){
++			case AVRCP_EVENT_TRACK_CHANGED:
++			DBG("Track changed baby!!!");
++			avrcp_register_notification(session, event);
++			break;
++			case AVRCP_EVENT_STATUS_CHANGED:
++			avrcp_register_notification(session, event);
++			break;
++		}
++		//session->registered_events ^= (1 << event);
++		//avrcp_register_notification(session, event);
++		return FALSE;
++	}
++
++	switch (event) {
++	case AVRCP_EVENT_VOLUME_CHANGED:
++	
++		//avrcp_volume_changed(session, pdu);
++		break;
++	case AVRCP_EVENT_STATUS_CHANGED:
++		strval = status_to_string(pdu->params[1]);
++		DBG("EVENT_STATUS_CHANGED: %s", strval);
++		//avrcp_status_changed(session, pdu);
++		break;
++	case AVRCP_EVENT_TRACK_CHANGED:
++		avrcp_get_element_attributes(session);
++		//DBG("Track changed baby!!!");
++		//avrcp_track_changed(session, pdu);
++		break;
++	case AVRCP_EVENT_SETTINGS_CHANGED:
++		//avrcp_setting_changed(session, pdu);
++		break;
++	case AVRCP_EVENT_AVAILABLE_PLAYERS_CHANGED:
++		//avrcp_available_players_changed(session, pdu);
++		break;
++	case AVRCP_EVENT_ADDRESSED_PLAYER_CHANGED:
++		//avrcp_addressed_player_changed(session, pdu);
++		break;
++	case AVRCP_EVENT_UIDS_CHANGED:
++		//avrcp_uids_changed(session, pdu);
++		break;
++	}
++
++	//session->registered_events |= (1 << event);
++
++	return TRUE;
++}
++
++static void avrcp_register_notification(struct control *con, uint8_t event)
++{
++	uint8_t buf[AVRCP_HEADER_LENGTH + AVRCP_REGISTER_NOTIFICATION_PARAM_LENGTH];
++	struct avrcp_header *pdu = (void *) buf;
++	uint8_t length;
++
++	memset(buf, 0, sizeof(buf));
++
++	set_company_id(pdu->company_id, IEEEID_BTSIG);
++	pdu->pdu_id = AVRCP_REGISTER_NOTIFICATION;
++	pdu->packet_type = AVRCP_PACKET_TYPE_SINGLE;
++	pdu->params[0] = event;
++	pdu->params_len = htons(AVRCP_REGISTER_NOTIFICATION_PARAM_LENGTH);
++
++	length = AVRCP_HEADER_LENGTH + ntohs(pdu->params_len);
++
++	avctp_send_vendordep_req(con->session, AVC_CTYPE_NOTIFY,
++					AVC_SUBUNIT_PANEL, buf, length,
++					avrcp_handle_event, con);
++}
++
++unsigned int avrcp_add_state_cb(avrcp_state_cb cb, void *user_data)
++{
++	struct avrcp_state_callback *state_cb;
++	static unsigned int id = 0;
++
++	state_cb = g_new(struct avrcp_state_callback, 1);
++	state_cb->cb = cb;
++	state_cb->user_data = user_data;
++	state_cb->id = ++id;
++
++	callbacks = g_slist_append(callbacks, state_cb);
++
++	return state_cb->id;
++}
++
++gboolean avrcp_remove_state_cb(unsigned int id)
++{
++	GSList *l;
++
++	for (l = callbacks; l != NULL; l = l->next) {
++		struct avrcp_state_callback *cb = l->data;
++		if (cb && cb->id == id) {
++			callbacks = g_slist_remove(callbacks, cb);
++			g_free(cb);
++			return TRUE;
++		}
++	}
++
++	return FALSE;
++}
+diff --git a/audio/avrcp.h b/audio/avrcp.h
+index bf11a6c..9593ad2 100644
+--- a/audio/avrcp.h
++++ b/audio/avrcp.h
+@@ -69,12 +69,16 @@
+ #define AVRCP_PLAY_STATUS_ERROR		0xFF
+ 
+ /* Notification events */
+-#define AVRCP_EVENT_STATUS_CHANGED	0x01
+-#define AVRCP_EVENT_TRACK_CHANGED	0x02
+-#define AVRCP_EVENT_TRACK_REACHED_END	0x03
+-#define AVRCP_EVENT_TRACK_REACHED_START	0x04
+-#define AVRCP_EVENT_VOLUME_CHANGED	0x0d
+-#define AVRCP_EVENT_LAST		AVRCP_EVENT_VOLUME_CHANGED
++#define AVRCP_EVENT_STATUS_CHANGED		0x01
++#define AVRCP_EVENT_TRACK_CHANGED		0x02
++#define AVRCP_EVENT_TRACK_REACHED_END		0x03
++#define AVRCP_EVENT_TRACK_REACHED_START		0x04
++#define AVRCP_EVENT_SETTINGS_CHANGED		0x08
++#define AVRCP_EVENT_AVAILABLE_PLAYERS_CHANGED	0x0a
++#define AVRCP_EVENT_ADDRESSED_PLAYER_CHANGED	0x0b
++#define AVRCP_EVENT_UIDS_CHANGED		0x0c
++#define AVRCP_EVENT_VOLUME_CHANGED		0x0d
++#define AVRCP_EVENT_LAST			AVRCP_EVENT_VOLUME_CHANGED
+ 
+ struct avrcp_player_cb {
+ 	int (*get_setting) (uint8_t attr, void *user_data);
+@@ -88,6 +92,14 @@ struct avrcp_player_cb {
+ 							void *user_data);
+ };
+ 
++typedef void (*avrcp_state_cb) (struct audio_device *dev,
++				//avrcp_state_t old_state,
++				//avrcp_state_t new_state,
++				void *user_data);
++				
++unsigned int avrcp_add_state_cb(avrcp_state_cb cb, void *user_data);
++gboolean avrcp_remove_state_cb(unsigned int id);
++
+ int avrcp_register(DBusConnection *conn, const bdaddr_t *src, GKeyFile *config);
+ void avrcp_unregister(const bdaddr_t *src);
+ 
+@@ -95,6 +107,8 @@ gboolean avrcp_connect(struct audio_device *dev);
+ void avrcp_disconnect(struct audio_device *dev);
+ int avrcp_set_volume(struct audio_device *dev, uint8_t volume);
+ 
++void avrcp_get_capabilities(struct control *con);
++
+ struct avrcp_player *avrcp_register_player(const bdaddr_t *src,
+ 						struct avrcp_player_cb *cb,
+ 						void *user_data,
+diff --git a/audio/control.c b/audio/control.c
+index 7555225..898bef3 100644
+--- a/audio/control.c
++++ b/audio/control.c
+@@ -50,19 +50,14 @@
+ #include "device.h"
+ #include "manager.h"
+ #include "avctp.h"
++#include "avrcp.h"
+ #include "control.h"
+ #include "sdpd.h"
+ #include "glib-helper.h"
+ #include "dbus-common.h"
+ 
+ static unsigned int avctp_id = 0;
+-
+-struct control {
+-	struct audio_device *dev;
+-	struct avctp *session;
+-
+-	gboolean target;
+-};
++static unsigned int avrcp_id = 0;
+ 
+ static void state_changed(struct audio_device *dev, avctp_state_t old_state,
+ 				avctp_state_t new_state, void *user_data)
+@@ -94,6 +89,7 @@ static void state_changed(struct audio_device *dev, avctp_state_t old_state,
+ 
+ 		break;
+ 	case AVCTP_STATE_CONNECTED:
++		avrcp_get_capabilities(control);
+ 		value = TRUE;
+ 		g_dbus_emit_signal(dev->conn, dev->path,
+ 				AUDIO_CONTROL_INTERFACE, "Connected",
+@@ -107,6 +103,33 @@ static void state_changed(struct audio_device *dev, avctp_state_t old_state,
+ 	}
+ }
+ 
++static void media_status_changed(struct audio_device *dev, 
++		void *user_data)
++{
++	struct control *con = user_data;
++	gboolean value = TRUE;
++	dbus_uint32_t serial = 0;
++	DBusMessage *msg;
++	DBusMessageIter args;
++	
++	char * array[7];	
++	char ** test = &array[0];
++	
++	array[0] = g_hash_table_lookup(con->metadata,"Title");
++	array[1] = g_hash_table_lookup(con->metadata,"Artist");
++	array[2] = g_hash_table_lookup(con->metadata,"Album");
++	array[3] = g_hash_table_lookup(con->metadata,"TrackNumber");
++	array[4] = g_hash_table_lookup(con->metadata,"NumberOfTracks");
++	array[5] = g_hash_table_lookup(con->metadata,"Genre");
++	array[6] = g_hash_table_lookup(con->metadata,"Duration");
++		
++	DBG("callback is called for %s",batostr(&dev->src));
++	DBG("%s",array[0]);
++	emit_array_property_changed(dev->conn, dev->path, AUDIO_CONTROL_INTERFACE,
++					"Metadata", DBUS_TYPE_STRING, &test, 7);
++					
++}
++
+ static DBusMessage *control_is_connected(DBusConnection *conn,
+ 						DBusMessage *msg,
+ 						void *data)
+@@ -293,11 +316,14 @@ struct control *control_init(struct audio_device *dev, uint16_t uuid16)
+ 
+ 	control = g_new0(struct control, 1);
+ 	control->dev = dev;
++	control->metadata = g_hash_table_new(g_str_hash, g_str_equal);
+ 
+ 	control_update(control, uuid16);
+ 
+ 	if (!avctp_id)
+ 		avctp_id = avctp_add_state_cb(state_changed, NULL);
++	if (!avrcp_id)
++		avrcp_id = avrcp_add_state_cb(media_status_changed, NULL);
+ 
+ 	return control;
+ }
+diff --git a/audio/control.h b/audio/control.h
+index 2219e5f..57b1b60 100644
+--- a/audio/control.h
++++ b/audio/control.h
+@@ -24,6 +24,13 @@
+ 
+ #define AUDIO_CONTROL_INTERFACE "org.bluez.Control"
+ 
++struct control {
++	struct audio_device *dev;
++	struct avctp        *session;
++	GHashTable          *metadata;
++	gboolean target;
++};
++
+ struct control *control_init(struct audio_device *dev, uint16_t uuid16);
+ void control_update(struct control *control, uint16_t uuid16);
+ void control_unregister(struct audio_device *dev);
+diff --git a/lib/sdp.h b/lib/sdp.h
+index 2fe74d5..df525ad 100644
+--- a/lib/sdp.h
++++ b/lib/sdp.h
+@@ -95,6 +95,7 @@ extern "C" {
+ #define AV_REMOTE_TARGET_SVCLASS_ID	0x110c
+ #define ADVANCED_AUDIO_SVCLASS_ID	0x110d
+ #define AV_REMOTE_SVCLASS_ID		0x110e
++#define AV_REMOTE_CONTROLLER_SVCLASS_ID 0x110f
+ #define VIDEO_CONF_SVCLASS_ID		0x110f
+ #define INTERCOM_SVCLASS_ID		0x1110
+ #define FAX_SVCLASS_ID			0x1111
+-- 
diff --git a/debian/patches/0017-True-Remove-remote-version-call.patch b/debian/patches/0017-True-Remove-remote-version-call.patch
new file mode 100644
index 0000000..532096a
--- /dev/null
+++ b/debian/patches/0017-True-Remove-remote-version-call.patch
@@ -0,0 +1,49 @@
+From: Nathaniel Cabalos <ncabalos@truefitness.com>
+Date: Fri, 26 April, 2014 13:35:57 -0500
+Subject: True-Remove-remote-version-call.patch
+
+---
+ plugins/hciops.c |    8 ++++----
+ 1 file changed, 4 insertions(+), 4 deletions(-)
+
+diff --git a/plugins/hciops.c b/plugins/hciops.c
+index d74f2ea..4bc95a8 100644
+--- a/plugins/hciops.c
++++ b/plugins/hciops.c
+@@ -2287,7 +2287,7 @@ static inline void conn_complete(int index, void *ptr)
+ 		bonding_complete(dev, conn, 0);
+ 
+ 	/* check if the remote version needs be requested */
+-	ba2str(&dev->bdaddr, local_addr);
++	/*ba2str(&dev->bdaddr, local_addr);
+ 	ba2str(&evt->bdaddr, peer_addr);
+ 
+ 	create_name(filename, sizeof(filename), STORAGEDIR, local_addr,
+@@ -2297,7 +2297,7 @@ static inline void conn_complete(int index, void *ptr)
+ 	if (!str)
+ 		get_remote_version(index, btohs(evt->handle));
+ 	else
+-		free(str);
++		free(str);*/
+ }
+ 
+ static inline uint8_t le_addr_type(uint8_t bdaddr_type)
+@@ -2334,7 +2334,7 @@ static inline void le_conn_complete(int index, void *ptr)
+ 								NULL, NULL);
+ 
+ 	/* check if the remote version needs be requested */
+-	ba2str(&dev->bdaddr, local_addr);
++	/*ba2str(&dev->bdaddr, local_addr);
+ 	ba2str(&evt->peer_bdaddr, peer_addr);
+ 
+ 	create_name(filename, sizeof(filename), STORAGEDIR, local_addr,
+@@ -2344,7 +2344,7 @@ static inline void le_conn_complete(int index, void *ptr)
+ 	if (!str)
+ 		get_remote_version(index, btohs(evt->handle));
+ 	else
+-		free(str);
++		free(str);*/
+ }
+ 
+ static inline void disconn_complete(int index, void *ptr)
+-- 
-- 
